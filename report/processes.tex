\section{Processes}

\subsection{Paging}

\subsubsection{Allocate free regions of virtual address space}
TODO

\subsubsection{Map large frames}
TODO

\subsubsection{Perform mapping in a different domain}
TODO

\subsubsection{Unmapping}
TODO

\subsection{Process Creation}

\subsubsection{Load from multiboot image}

At the moment we can only load binaries that are included in the boot image as we dont have a filesystem yet. So we need to find our binary by looking for it by its filepath in the boot image first.
Once we found it we start setting up our bookkeeping for a spawned process. Here we set the name of the process to the binary name and store the module location that holds the binary.
We also need to load the binaries arguments from the boot image as they are also hardcoded in there. We get them as e raw string and hence they need to be parsed. The chosen argument seperator here is a whitespace. If there are multiple whitespaces between the arguments, they are stripped.
As we later want to load binaries not only from the boot image but also from the filesystem we moved the following part into another api endpoint so the common functionality to actually spawn a process can be shared.

\subsubsection{Find ELF image}
We will now refer to the process that spawns a process the parent and the spawned process the child.
To work with the binary we need to map it into the parents virtual memory space. For this we map the address of the module into our vspace with the help of our paging infrastructure.
To check whether we mapped the modulo correctly we can try to access the first four bytes of the mapped address in the parents virtual memory spaces. As we mapped a ELF binary the should be the ELF macig bytes namels '0x7f', 'E', 'L' and 'F'.

\subsubsection{Create intial CSpace}
Next we need to setup the capability space of the child. It has the well known layout of one root L1 Cnode and then multiple L2 CNodes in some predefined slot of the L1 CNode.
So first we create the L1 root cnode. From this we can create the L2 CNodes: task cnode, three slot cnodes, the base page cnode and the page cnode.
The task cnode holds multiple capabilities such as the dispacher, dispacher frame, argument page, the endpoint to itself (created from the dispatcher capability) and the root cnode from above.
At this point we also copy the parents endpoint to a well known location in the child cspace such that the child can use it later to setup a channel to the parent for inter process communication.
The three slot cnode are empty and contain space for the child's initial slot allocator and more if needed.
Each slot of the base page cnode hold a ram capability of the base page size such that the child has some initial memory to work with.
Finally the page cnode has in the first slot a capability to the top level page table. The other slots can be used to store other page tables.

\subsubsection{Create initial VSpace}
In the child's virtual memory space we need to create a L0 page table and store it in the page cnode. We also need to copy the L0 page table to the parent virtual memory space so we can invoke it. This is needed to setup the paging infrastructure for the child. If we would not map it into the parents vspace we wouldn't have the right to write to it.
As already mentioned above, we need to store empty ram caps in the base page cnode, therefore we need to allocate them and store them in the corresponding slots.

\subsubsection{Load the ELF Image}
Now that we have a working virtual memory space in the child, we can parse the ELF binary and load the segments in the childs virtual memory space. This work by defining a callback function that is called for each segment that is encountered in the ELF binary.
In the callback function we allocate first a frame in the parents vspace and map the segment frame the callback function was called for into the frame. We also need to tranlsate the access rights from the ELF binary segments to the virtual memory space as they are be different. We first map it into the parents vspace again to be allowed to make operations on it. After the parent is finished the final frame is also mapped into the childs vspace.
Finally, the binary is parsed for the global offset table header such that we can initialize the child properly.

\subsubsection{Adding a dispatcher}
To setup a dispatcher we first need to allocate a dispatcher frame. This frame is used by the CPU driver to store information about the process.
Here again we map the frame into the parents vspace and the childs vspace.
To finish things up, we setup the dispatcher fields and put initial information in the dispatcher frame scuh aus core id, virtual address of the dispatcher frame in the childs vspace, the process name, the programm counter and tell the child to start in the disabled mode.
Finally, we initialize the offset registers and disable the error handling frames.

\subsubsection{Set up arguments}
The child process also needs to know with what arguments it has been invoked with. For this another frame is allocated and mapped into both vspaces.
The frame is expected to have a specific layout namely first a struct with some meta information of the frame such as at which address each argument is located.
This struct is followed by the actual arguments until it is finished by a NULL pointer.
The child process expected its first argument in the enabled save area to contain a pointer to the above mentioned struct, so we set that at the end.

\subsubsection{Start the process}
Invoking the dispatcher is the easy part, namely calling a sys call with the correct arguments we just set up.

\subsection{Process Management}

\subsubsection{Datastructure}
We chose a simple linked list for storing the currently running processes. The head is well known with the init process being the first process in the system.
All other later spawned processes are appended to the linked list.
Each process gets a PID assigned, after the process was is invoked by checking whether the current PID counter is already used or is incremented otherwise until a free one is found.

\subsubsection{Kill a process}
Killing a process identified by its PID now boils down to traversing the linked list until we found the matching process stoping its dispatcher and removing from the linked list.


\subsection{Pitfalls}
We had some serious trouble with refills during a page mapping. Namely, when we run out of slots/slabs and attempted a refill, it may happen that the refill actually used the page we wanted to map, resulting in an error. We solved that by ensuring that no refills happended during an ongoing mapping.

Another interesing bug occured during tests of spawning many processes. The first four prosses spawned just fine but when trying to spawn the fifth process the whole system collapsed without an obvious error. After some debugging it turned out we stored the metadata of a spawning process in the test on the stack and with 4 processes the stack was full and the init process terminated. We solved that by storing the metadata on the heap instead.

% other pitfalls:
% virtual address starts at 0 instead of VADDR_OFFSET
% overwrite string termination of args
% reuse same datastrucuture for process creation
