\chapter{Processes}

\section{Paging}

\subsection{Allocate free regions of virtual address space}
TODO

\subsection{Map large frames}
TODO

\subsection{Perform mapping in a different domain}
TODO

\subsection{Unmapping}
TODO

\section{Process Creation}

\subsection{Load from multiboot image}

At the moment we can only load binaries that are included in the boot image as
we dont have a filesystem yet. So we need to find our binary by looking for it
by its filepath in the boot image first.  Once we found it we start setting up
our bookkeeping for a spawned process. Here we set the name of the process to
the binary name and store the module location that holds the binary.  We also
need to load the binaries arguments from the boot image as they are also
hardcoded in there. We get them as e raw string and hence they need to be
parsed. The chosen argument seperator here is a whitespace. If there are
multiple whitespaces between the arguments, they are stripped.  As we later want
to load binaries not only from the boot image but also from the filesystem we
moved the following part into another api endpoint so the common functionality
to actually spawn a process can be shared.

\subsection{Find ELF image} 

We will now refer to the process that spawns a
process the parent and the spawned process the child.  To work with the binary
we need to map it into the parents virtual memory space. For this we map the
address of the module into our vspace with the help of our paging
infrastructure.  To check whether we mapped the modulo correctly we can try to
access the first four bytes of the mapped address in the parents virtual memory
spaces. As we mapped a ELF binary the should be the ELF macig bytes namels
'0x7f', 'E', 'L' and 'F'.

\subsection{Create intial CSpace} 

Next we need to setup the capability space of
the child. It has the well known layout of one root L1 Cnode and then multiple
L2 CNodes in some predefined slot of the L1 CNode.  So first we create the L1
root cnode. From this we can create the L2 CNodes: task cnode, three slot
cnodes, the base page cnode and the page cnode.  The task cnode holds multiple
capabilities such as the dispacher, dispacher frame, argument page, the endpoint
to itself (created from the dispatcher capability) and the root cnode from
above.  At this point we also copy the parents endpoint to a well known location
in the child cspace such that the child can use it later to setup a channel to
the parent for inter process communication.  The three slot cnode are empty and
contain space for the child's initial slot allocator and more if needed.  Each
slot of the base page cnode hold a ram capability of the base page size such
that the child has some initial memory to work with.  Finally the page cnode has
in the first slot a capability to the top level page table. The other slots can
be used to store other page tables.

\subsection{Create initial VSpace} 

In the child's virtual memory space we need
to create a L0 page table and store it in the page cnode. We also need to copy
the L0 page table to the parent virtual memory space so we can invoke it. This
is needed to setup the paging infrastructure for the child. If we would not map
it into the parents vspace we wouldn't have the right to write to it.  As
already mentioned above, we need to store empty ram caps in the base page cnode,
therefore we need to allocate them and store them in the corresponding slots.

\subsection{Load the ELF Image} 

Now that we have a working virtual memory space
in the child, we can parse the ELF binary and load the segments in the childs
virtual memory space. This work by defining a callback function that is called
for each segment that is encountered in the ELF binary.  In the callback
function we allocate first a frame in the parents vspace and map the segment
frame the callback function was called for into the frame. We also need to
tranlsate the access rights from the ELF binary segments to the virtual memory
space as they are be different. We first map it into the parents vspace again to
be allowed to make operations on it. After the parent is finished the final
frame is also mapped into the childs vspace.  Finally, the binary is parsed for
the global offset table header such that we can initialize the child properly.

\subsection{Adding a dispatcher} 

To setup a dispatcher we first need to allocate
a dispatcher frame. This frame is used by the CPU driver to store information
about the process.  Here again we map the frame into the parents vspace and the
childs vspace.  To finish things up, we setup the dispatcher fields and put
initial information in the dispatcher frame scuh aus core id, virtual address of
the dispatcher frame in the childs vspace, the process name, the programm
counter and tell the child to start in the disabled mode.  Finally, we
initialize the offset registers and disable the error handling frames.

\subsection{Set up arguments} 

The child process also needs to know with what
arguments it has been invoked with. For this another frame is allocated and
mapped into both vspaces.  The frame is expected to have a specific layout
namely first a struct with some meta information of the frame such as at which
address each argument is located.  This struct is followed by the actual
arguments until it is finished by a NULL pointer.  The child process expected
its first argument in the enabled save area to contain a pointer to the above
mentioned struct, so we set that at the end.

\subsection{Start the process} 

Invoking the dispatcher is the easy part, namely
calling a sys call with the correct arguments we just set up.

\section{Process Management}

\subsection{Datastructure} 

We chose a simple linked list for storing the
currently running processes. The head is well known with the init process being
the first process in the system.  All other later spawned processes are appended
to the linked list.  Each process gets a PID assigned, after the process was is
invoked by checking whether the current PID counter is already used or is
incremented otherwise until a free one is found.

\subsection{Kill a process} 

Killing a process identified by its PID now boils
down to traversing the linked list until we found the matching process stoping
its dispatcher and removing from the linked list.


\section{Pitfalls} 

We had some serious trouble with refills during a page
mapping. Namely, when we run out of slots/slabs and attempted a refill, it may
happen that the refill actually used the page we wanted to map, resulting in an
error. We solved that by ensuring that no refills happended during an ongoing
mapping.

Another interesing bug occured during tests of spawning many processes. The
first four prosses spawned just fine but when trying to spawn the fifth process
the whole system collapsed without an obvious error. After some debugging it
turned out we stored the metadata of a spawning process in the test on the stack
and with 4 processes the stack was full and the init process terminated. We
solved that by storing the metadata on the heap instead.

% other pitfalls:
% virtual address starts at 0 instead of VADDR_OFFSET
% overwrite string termination of args
% reuse same datastrucuture for process creation
